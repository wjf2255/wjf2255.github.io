---
title: 最终一致性
tags: [设计模式, 分布式系统, CAP, 最终一致性]
layout: post
author: wjf
---

<div id="table-of-contents">
<h2>目录</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orga7156df">目的</a></li>
<li><a href="#orgbf73a37">利用数据库事务保证数据的一致性</a>
<ul>
<li><a href="#orgbf50594">ACID</a></li>
<li><a href="#org96cc2ff">事务的分类</a></li>
<li><a href="#org0f82e79">事务的隔离级别</a></li>
<li><a href="#org148873f">事务之外的其他的问题</a></li>
</ul>
</li>
<li><a href="#org5b874a0">CAP 理论</a>
<ul>
<li><a href="#org1fa943a">CAP 取舍</a></li>
</ul>
</li>
<li><a href="#org41ff9dc">最终数据一致性方案</a>
<ul>
<li><a href="#org3d6d344">业务整合</a></li>
<li><a href="#orge550d95">异步消息</a></li>
<li><a href="#org7ae5642">业务补偿</a></li>
<li><a href="#org67a8420">讨论中的补偿方案</a></li>
</ul>
</li>
</ul>
</div>
</div>


<a id="orga7156df"></a>

# 目的

后端研发的本质就是根据业务需求，设计各种数据结构（包括数据库、reids、ES 等的数据结构设计），并在处理各个业务功能时维护数据。维护数据的工作包括对数据的增删改查等操作。之所以需要设计数据结构，是为了更方便的维护数据（维护工作包括当前需求能够方便开发和实现，以后能够方便扩展）。在处理数据的各项工作当中，保护数据的准确性是一项非常重要的工作内容，尤其是核心业务的数据准确性。我们业务的处理一般都是根据现有的数据，处理和产生新的数据。如果出现数据准确性的问题，我们将无法预知业务的操作结果。维护数据是后端研发的最基础的工作，我们应当要维护好这些数据。

但是在现有的 bug 列表中，有许多 bug 都是数据问题导致的。由于数据库中存在很多异常情况的数据，导致很多业务无法正常正常处理或者数据展现让人无法理解。我们应当要保证在每个业务操作中，保证操作数据的一致性。

如何保证数据准确性是一项非常庞大而复杂的工作，我们这次主要讨论通过数据库事务和数据最终一致性的方案达到业务操作数据的准确性。


<a id="orgbf73a37"></a>

# 利用数据库事务保证数据的一致性

现有的 MySQL 提供了事务来保证数据的一致性。一些列满足 ACID 特性的数据库操作，可以视为一个单一的逻辑操作，这个单一的逻辑操作称为事务。满足 ACID 特性的操作的主要特点就是，这一系列的数据库操作，要么全部成功，要么全部失败。


<a id="orgbf50594"></a>

## ACID

ACID（Atomicity, Consistency, Isolation, Durability）是数据库系统为了即使是出现错误，电力故障等异常情况下，保证数据的有效性的一系列特性。


<a id="org519672d"></a>

### 原子性（Atomicity）：原子性要求任何一个事务操作要么成功，要么失败。如果事务中的部分数据操作失败，那么整个事务失败，数据库中的数据不做任何变化。一个原子性的系统需要保证出现异常，系统崩溃等情况下都能够保持数据的有效性。


<a id="org179c894"></a>

### 一致性（Consistency）：数据在事务的执行过程中，数据库的完整性没有被破坏。即写入的数据完全符合预定规则，比如数据库字段的限制条件、外键索引、触发器等。


<a id="orgc6eea2e"></a>

### 隔离性（Isolation）：事务的隔离性保证在并发情况下执行事务的时候，保证事务并发执行不会因为交叉执行而导致数据的不一致性。事务的隔离级别包括读未提交(Read Uncommitted)、读已提交（Read Committed）、可重复度（Repeatable Read）和串行化（Serializable）。


<a id="org7af9a2a"></a>

### 持久性：持久性保证在事务提交后，对数据的修改就是永久的，即便系统故障、错误或者崩溃的情况下，数据也不会丢失。对于关系型数据库来说，一旦提交了事务，数据需要存储到类似硬盘等非易失性存储器中。


<a id="org96cc2ff"></a>

## 事务的分类

数据库事务有许多种分类，用在不同的业务场景中。


<a id="org3e51f07"></a>

### 扁平事务

扁平事务是指所有的事务操作都处于同一层级。在不做特殊处理的情况下，默认都是使用扁平事务。扁平事务的缺点是不能提交回滚到事务的某一部分，而是全部回滚。


<a id="org1ec1bfd"></a>

### 链事务

如果事务中操作的数据非常复杂，而且每次出错都只需要回滚某一些数据操作，那么我们可以使用链事务。链事务可以在一系列的数据操作中插入保存点，一旦出现错误，事务会滚到最近的保存点。


<a id="orgc4ec22f"></a>

### 带有保存点的扁平事务

和链事务一样，可以支持在一系列的数据操作中加入保存点，区别在于回滚时，可以指定回滚到哪个保存点。


<a id="orge5ebe68"></a>

### 嵌套事务

目前 MySQL 不支持（？）该事务。


<a id="orgc8b0636"></a>

### 分布式事务

分布式事务是为了保证多个数据源之间数据保持一致性。


<a id="org56869b2"></a>

#### X/Open DTP 模型

X/Open 组织（即现在的 Open Group）定义了分布式事务处理模型。该模型定义了应用程序（AP），事务管理器（TM），资源管理器（RM），通信资源管理器（CRM）。它们之间的关系如下：

![img](/assets/image/分布式事务处理模型.gif "X/Open 分布式事务处理 (DTP) 模型")

通常把一个数据库内部的事务处理称为本地事物，而多个数据库（数据源）之间实现类似本地事务的操作成为全局事务。由于数据库本身无法知道其他数据库的操作，所以需要一个事务管理器来协调相关数据库做提交或者回滚。二阶段提交协议和三阶段提交协议就是根据 X/Open DTP 模型设计的常用的实现分布式事务的协议。


<a id="orgfdfee40"></a>

#### 二阶段提交协议（Two-phaseCommit）

二阶段提交协议将事务的提交分成两个阶段完成，分别是准备阶段和提交阶段。在“准备阶段”，事务管理器给每个本地事务发送是否可以提交消息消息，并开始等待各个本地事务的答复。等到各个本地事务的结果返回的时候（包括超时），进入第二个阶段“提交阶段”。如果事务管理器接收到任一本地事物操作失败或者超时时，直接给所有的参与者发送回滚消息；否则等待所有都正常执行时，发送提交消息。
二阶段提交协议是非常常用并且应用非常广的分布式事务协议和分布式消息协议，但是存在几个问题：

1.  同步阻塞问题。事务管理器需要等待所有本地事务的操作结果都返回才能做下一步操作，进而导致各个本地事务都需要等待最后一个本地事物执行完毕后才能做提交操作。
2.  单点故障。事务管理器一旦发生故障，则各个本地事务会一直阻塞。
3.  如果事务管理器在给所有的本地事务发送提交消息过程中发生消息丢失，则无法保证数据的一致性。


<a id="orgd396034"></a>

#### 三阶段提交协议（Three-phaseCommit）

三阶段对二阶段提交做了一些改进，加入了 pre-commit 阶段。


<a id="org0f82e79"></a>

## 事务的隔离级别

可以利用 sql 命令查看当前的事务隔离级别

    SELECT @@global.tx_isolation;
    +-----------------------+
    | @@global.tx_isolation |
    +-----------------------+
    | REPEATABLE-READ       |
    +-----------------------+
    1 row in set (0.04 sec)
    ，
    mysql> SELECT @@session.tx_isolation;
    +------------------------+
    | @@session.tx_isolation |
    +------------------------+
    | REPEATABLE-READ        |
    +------------------------+
    1 row in set (0.03 sec)

数据库事务隔离级别是 4 个，分别是读未提交（READ-UNCOMMITTED），读已提交（READ-COMMITTED），可重复读（REPEATABLE-READ）,串行化（SERIALIZABLE），InnoDB 默认的事务隔离级别是可重复读（REPEATABLE READ）。

-   读未提交（READ-UNCOMMITTED）是指并行的事务中，一个事务可以读取其他事务中未提交的修改的数据。即事务在读取数据的时候并没有对数据加锁，事务在修改数据的时候只对数据增加行级锁（共享读锁）。事务 1 读取 row1 记录时，事务 2 也能对这行记录进行读写。当事务 2 更新这条记录并且未提交时，事务 1 能读到修改后的结果。当事务 2 更新 row1 这条记录时，事务 1 在事务 2 结束前不能更新 row1 这条记录。如果事务 1 更新了 row1 记录之后，并发事务 2 修改读取了 row1 这条记录，事务 1 回滚， 事务 2 读取到的 row1 记录无效了。这种现象称为脏读。
- 读已提交（READ-COMMITTED）是指并发事务中，事务 1 在修改了 Row1 并且没有提交事务前，其他并发事务不允许读到 row1 的修改。事务 1 读取数据 row1 时，会对 row1 加上行级共享锁（读到数据时加上锁，一旦读取完毕则释放锁），在修改 row1 加上行级排它锁，直到事务结束才释放。并发事务 1 在读取 row1 时，并发事务 2 可以进行读取，但是在事务 1 进行读取操作时，不能修改 row1。一旦事务 1 读取 row1 之后，尽管事务 1 还未提交，事务 2 还是可以修改 row1。事务 1 更新 row1 时，并发事务 2 不可以更新 row1，直到事务 1 结束，事务 2 才回更新 row1 的值。事务 1 读取了记录 row1，并发事务 2 更新了 row1,并且提交。事务 1 再次读取 row1 时，发现前后不一致了。这种现象就是不可重复读。
- 可重复读（REPEATABLE-READ）是为了解决读已提交产生的可重复度的问题（名字起的相当任性）。事务在读取数据的瞬间加上行级共享锁，直到事务结束才释放；在写数据时，加上行级排它锁，直到事务结束才释放。可重复读的处理方式就是加响应的锁，并将锁的生命周期扩大到整个事务，但是如果是新增的数据会有新的问题。事务 1 查询一个数据集，事务 2 新增了一条在这个查询范文内的记录并提交，事务 1 再次查询该数据集，返现前后两次还是不一样。这种现象称为幻读。
- 串行化（SERIALIZABLE）在事务读取数据时，对整个表加共享锁，直到事务结束才释放；在更新数据时，对表加表级排它锁，知道事务结束。虽然以上介绍的脏读、不可重复读、幻读等现象都能解决，但是依然会有一些问题存在：
    1.  无法读取其他事务已经修改，但是未提交的数据

    2. 容易阻塞。



## 事务之外的其他的问题

我们使用的是可重复读的事务隔离级别（mysql 默认的事务隔离级别），如果业务场景需要考虑处理幻读或者重复录入的问题时，需要做其他处理，事务本身无法为我们解决这类问题。


<a id="org0ae8545"></a>

### 并发事务重复修改的问题

在处理业务时，需要根据这数据的现有的值，做判断，进而对其做修改，比如员工的积分。在对员工做减分操作时，我们需要先检查员工现有积分是否小于被减值，是则直接做减操作，否则只能减到 0。但是当我们查员工积分时，同时存在另外一个并发事务也是做减分操作，并且先执行完毕，那么会导致当前事务的减分操作可能会减到小于 0 分。为了解决此类问题，数据库提供了悲观锁以及我们可以设计一个乐观锁。


<a id="orgda68df9"></a>

#### 悲观锁

SELECT \* FROM userdb.user<sub>employee</sub> WHERE id = ? FOR UPDATE，此时会给查询到的记录加上行级排它锁，其他任何查询这些记录时，无法加上行级共享锁，只能等待这个行级排它锁释放，即等待当前事务提交或者回滚。


<a id="org60221c0"></a>

#### 乐观锁

在查询出这条记录做修改的时候，加上查询出的积分作为修改条件：update userdb.user<sub>employee</sub> set award = ? where id = ? and award = ?。如果有其他事务有修改过 award 的值，那么该操作不成功，返回 0，那么需要进一步做业务处理；可以给当前表加一个版本号，每次修改积分的同时，修改版本号。修改条件也要加上当前版本号。


<a id="orgc7c8b15"></a>

### 并发事务数据添加的问题

在处理业务时，比如添加潜在候选人（一个不是这家公司的员工，没有把这家公司下的所有职位都投递一遍的普通 C 端账号在浏览任意职位时，会成为这家公司的潜在候选人），会先查找潜在候选人在不在，如果不在，进行添加；否则修改浏览职位的次数。

    CandidateCompany candidateCompany = query("select * from candidatedb.candidate_company where company_id = ? and sysuser_id = ?");
    if(candidateCompany == null) {
        query("insert into candidatedb.candidate_company(*) values(*)");
    }

在高并发的情况下，一个用户在极快的时间里，浏览了一家公司下的许多职位，那么在查询时都查不到潜在候选人信息，但是却在这家公司下生成多条潜在候选人信息。


<a id="org403e2b8"></a>

#### 数据库的唯一索引

为了应对此类问题，可以采用数据唯一索引的方式，对重复添加抛出唯一索引异常，再让业务端处理此类异常。


<a id="org4c0cd2c"></a>

#### 子查询过滤

可以利用 sql 子查询的方式做过滤，比如: insert into insert into candidatedb.candidate<sub>company</sub>(**) values(**) if not exist (select \* from candidatedb.candidate<sub>company</sub> where company<sub>id</sub> = ? and sysuser<sub>id</sub> = ?);
如果返回 1，则表示正常录入，否则表示有重复数据。业务端根据该结果进行流程控制。


<a id="org5b874a0"></a>

# CAP 理论

CAP 理论也叫做 Brewer's 理论。这个理论断定在一个分布式的数据系统中，无法同时满足以下三种特性：

1.  一致性（Consistency）:所有的数据节点数据副本相同。
2.  可用性(Availability)：服务的读写是一直都是可以成功的。
3.  分区容错性（Partition Tolerance）：分布式系统在遇到某一节点或者网络分区故障时，仍然能够对外提供满足一致性和可用性的服务在。

![img](/assets/image/cap.jpg)

允许至少一个节点更新状态会导致数据不一致，即丧失了 C 性质。如果为了保证数据一致性，将分区一侧的节点设置为不可用，那么又丧失了 A 性质。除非两个节点可以互相通信，才能既保证 C 又保证 A，这又会导致丧失 P 性质。


<a id="org1fa943a"></a>

## CAP 取舍


<a id="org5a2f19d"></a>

### CA without P：如果不要求 P，那么 CA 可以满足。


<a id="org815670d"></a>

### CP without A: 如果不要求，那么相当于每个请求都需要在服务间强一致性。传统的分布式事务。


<a id="org70d033b"></a>

### AP without C: 高可用并允许分区，则需要放弃一致性。


<a id="org41ff9dc"></a>

# 最终数据一致性方案

系统保证在没有后续更新的前提下，系统最终返回上一次更新操作的值。在没有故障发生的前提下，不一致窗口的时间主要受通信延迟，系统负载和复制副本的个数影响。DNS 是一个典型的最终一致性系统。


<a id="org3d6d344"></a>

## 业务整合

尽量把需要数据一致性的业务整合到一起，利用本地事务的方式处理数据一致性的问题。

-   优点：规避了分布式事务
-   缺点：把本来拆分好的业务有重新耦合到一起；随着业务推进，业务越来越难以规划。


<a id="orge550d95"></a>

## 异步消息

eBay 在 10 年前的方案，将需要分布式处理的任务，通过异步消息的方式异步执行。消息日志可以存储到本地文本、数据库或消息队列，再通过业务规则自动或人工发起重试。

-   优点：方便开发
-   缺点：需要保证消息的安全性；需要保证消息消费端的业务幂等性。


<a id="org7ae5642"></a>

## 业务补偿

对于需要考虑数据一致性的业务接口，同时提供一个补偿接口。在业务调用方设计实现一个二阶段提交的逻辑。如果遇到业务回滚，则调用该接口的补偿接口。


<a id="org67a8420"></a>

## 讨论中的补偿方案

针对 eBay 的方案做一些扩展。如下图所示：

![img](/assets/image/eventual_consistency.png)

业务处理方通过消息中间发送异步消息，通知业务消费方处理业务。

1.  为了确保消息中间件的稳定性，搭建消息中间件集群。
2.  为了确保消息的不丢失，队列设置为持久化的队列，将消息存储到磁盘。
3.  为了确保消息能够发送成功，创建消息发送记录表，利用本地事务的方式在发送前保存这表消息记录。创建消息定时发送任务，定时查找未完成消息，并加你个消息重新发送到队列中。如果重试多次（比如 3 次），出发报警，要求人工介入。
4.  消息消费方需要保证接口幂等性。如果业务可以区分幂等性问题，那么根据业务处理，如果业务本身不能区分幂等性，那么需要通过检查消费日志的方式，校验该业务是否已经处理。未消息未消费则进行业务处理，并添加消费日志；否则视为已经消费处理。
5.  消息消费完毕后需要更新消息发送记录，标记为已经处理。相同数据库实例下，直接通过数据库更新；不同数据库实例并无法访问的情况下，则通过消息中间件处理。

