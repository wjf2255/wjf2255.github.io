---
title: JUC 锁源码介绍
tags: [Java, JUC, 源码, 多线程, 锁]
layout: post
author: wjf
---

<div id="table-of-contents">
<h2>目录</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org87845a3">Lock</a></li>
<li><a href="#orgb2d87c6">ReentrantLock</a></li>
<li><a href="#orgd0a0f2d">ReadWriteLock</a></li>
<li><a href="#orgc616c40">ReentrantReadWriteLock</a></li>
</ul>
</div>
</div>


<a id="org87845a3"></a>

# Lock

Lock 是定义锁的接口，位于 java.util.concurrent.locks 包下。锁时用来控制线程访问共享资源的工具，比起 Synchronized 关键词实现的同步方式，锁更加灵活，并且能够支持静态条件（Condition）。通常情况下锁提有两种策略，一种是同一时刻只允许一个线程访问资源，另一种是一个时刻允许多个线程同时访问共享资源，比如 ReadWriteLock 中的写锁和读锁。

Lock 用于补充 synchronized 关键词实现的多线程同步功能。synchronized 通过监视器（monitor）机制控制线程访问共享资源。监视器机制控制一个时刻只能有一个线程进入共享资源，而如果发生多线程竞争同样的共享资源，那么这些线程将会被按顺序阻塞。直到当前线程释放共享资源后（退出 synchronized 代码块），被阻塞的线程会被按顺序唤醒。这是一个先进先出的队列，而且使用者无法改变。

Lock 可以定义释放锁的顺序，可以定义独占锁和共享锁，可以定义超时时间，它丰富了 Java 锁的功能。但是 Lock 在使用上比 synchronized 复杂。一个常见的使用方式如下：

    l.lock();
    try {
      // access the resource protected by this lock
    } finally {
      l.unlock();
    }

一旦使用锁的上锁方法，必须要保证这个锁被释放掉。为了防止被异常，return 跳出打断，释放锁的方法要求在 finally 中执行。

Lock 的定义了 synchronized 不具备的方法，比如获取到锁前不阻塞线程（tryLock），响应中断（lockInterruptibly），可以设置获取锁的超时时间（tryLock(long, TimeUnit)）。Lock 还可以保证按照顺序唤醒等待线程，可以自定义不可重入的特性，检测死锁。

Lock 是指一个普通的 Java 类，在具体实现中允许在 synchronized 的代码块中，但是不建议这么使用。

除非特殊说明，任何需要传参的方法中，如果参数是 null，则抛出空指针异常。

所有的锁的实现都必须符合 Java 定义的内存模型（[The Java Language Specification (17.4 Memory Model)](https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4)）

接口定义如下：

    ```java
    public interface Lock {
    
      /**
       * 获取锁
       * 如果当前线程无法获取锁，那么会导致线程被阻塞，知道允许获取锁为止。
       * lock()的实现类需要注意由于错误使用可能会导致死锁，引发未检测的异常等问题，需要实现类本身探测并在文档中说明。
       */
      void lock();
    
      /**
       * 获取锁，并且能够响应线程中断
       * 如果能够成功获取，那么立即返回 true。
       * 如果获取锁失败，那么线程将会被阻塞。
       * 在阻塞过程中，如果当前线程能够获取到锁，那么当前线程将会被唤醒，并返回 true。
       * 在阻塞过程中，如果当前线程被中断，并且获取锁方法能够响应中断，那么当前线程会被唤醒，
       * 并清空中断状态，抛出中断异常（InterruptedException）。
       *
       * 注意：
       * 1. 响应中断不是所有场景都能支持，并且响应中断可能是一个耗费资源的操作。实现时需要说明这个情况。
       * 2. 实现类需要注意由于错误使用可能会导致死锁，引发未检测的异常等问题，需要实现类本身探测并在文档中说明。
       *
       * @throws 在获取锁期间如果线程被中断，并中断操作能够被支持，那么抛出线程中断异常。
       */
      void lockInterruptibly() throws InterruptedException;
    
      /**
       * 尝试获取锁。
       * 如果能够获取到锁，那么返回 true，如果当前无法获取到锁，那么返回 false
       */
      boolean tryLock();
    
    
    
      /**
       *
       * 获取锁。增加等待锁的超时时间和响应线程中断的功能。
       *
       * @param time the maximum time to wait for the lock
       * @param unit the time unit of the {@code time} argument
       * @return {@code true} if the lock was acquired and {@code false}
       *         if the waiting time elapsed before the lock was acquired
       *
       * @throws InterruptedException if the current thread is interrupted
       *         while acquiring the lock (and interruption of lock
       *         acquisition is supported)
       */
      boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
    
      /**
       * 释放锁
       * 释放锁通常是由获取到的线程才能释放，如果违背这个约束条件会抛出异常。这个约束条件和异常类型实现类必须要做说明。
       */
      void unlock();
    
      /**
       * Lock 定义了支持竞态条件的方法。该方法用于定义创建新的竞态条件。
       *
       * @return A new {@link Condition} instance for this {@code Lock} instance
       * @throws UnsupportedOperationException if this {@code Lock}
       *         implementation does not support conditions
       */
      Condition newCondition();
    ```

<a id="orgb2d87c6"></a>

# ReentrantLock

可重入锁（ReentrantLock）的行为和 synchronize 类似，但是做了一些功能上的扩展。比如一个线程已经持有了可重入锁，再还未释放前，允许其他线程成功获取锁。

可重入锁可以提供公平锁和非公平锁。如果构造函数参数是 true，提供公平锁；否则提供非公平锁。公平锁会保证锁给到等待时间最长的线程。通常情况下公平锁和非公平锁在获取锁和保证锁分配的性能差不多，但是总体上使用公平锁比非公平锁性能差。因为线程唤醒有重大延迟，但是公平锁后续进来的线程有一定会排到后面从而无法利用这个时间片，但是非公平锁可以。公平锁保证顺序是通过一个 FIFO 队列，如果队列中有元素，那么无法获取到锁，将线程排队队列尾部。但是如果此时队列中没有任何元素，由于公平锁无法保证线程调度的顺序和频率，所以无法保证第一次多个线程竞争锁时的同步问题。

重入锁的使用建议是是方法一开始就做锁操作，后续直接跟 try {} finally {}语句，在 finally 中做释放锁操作。代码如下：

    ```java
    class X {
    
    private final ReentrantLock lock = new ReentrantLock();
    //...
        public void m() {
            lock.lock();  // block until condition holds
            try {
                // ... method body
            } finally {
                lock.unlock();
            }
        }
    }
    ```

可重入锁除了锁的方法的实现外，还提供了一些用来返回锁的状态的方法，为监控锁的运行情况提供便利。

可重入锁是可以序列化和反序列化的。但是反序列化后的锁的状态都是未锁定的状态，不会把序列化签的锁的状态反序列化回来。

可重入锁能够最大支持 2147483647 次重入操作，超过这个限制发生报错。

可重入锁内置了一个内部静态类 Sync，为读写锁提供线程同步功能。内置了公平锁和非公平锁，提供公平锁和非公平锁的服务。

静态类 Sync 代码如下：

    ```java
    /**
     * 同步器 AbstractQueuedSynchronizer 的子类，主要为重入锁提供线程同步的功能。
     * 这里的 AbstractQueuedSynchronizer 的 state 表示多少个线程持有当前锁。
     */
    abstract static class Sync extends AbstractQueuedSynchronizer {
        private static final long serialVersionUID = -5179523762034025860L;
    
        /**
         * 上锁。
         * 具体交由子类实现。非公平锁获取锁的方式可以利用 CAS 的方式将 state 从 0 变成 1，如果操作成功可以快速获取锁。
         */
        abstract void lock();
    
        /**
         * 尝试获取非公平锁。如果获取成功返回 true，否则返回 false。
         */
        final boolean nonfairTryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            if (c == 0) {
                //利用 CAS 的方式获取锁。
                if (compareAndSetState(0, acquires)) {
                    //将同步器（AbstractOwnableSynchronizer）的 exclusiveOwnerThread 设置成当前线程。
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            //当前线程和同步器的 exclusiveOwnerThread 值相同表示线程再次获取相同的锁（ReentrantLock 的重入锁特性）。
            else if (current == getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                //由于最高位是符号位，如果超过正数的上限，会变成负数。所以最多可以重入 2147483647 次
                if (nextc < 0) // overflow
                    throw new Error("Maximum lock count exceeded");
                setState(nextc);
                return true;
            }
            return false;
        }
    
        /**
         * 释放锁
         */
        protected final boolean tryRelease(int releases) {
            //由于是释放锁，所以 getState 最少有一次，如果重入，最多可以有 2147483647。
            int c = getState() - releases;
            if (Thread.currentThread() != getExclusiveOwnerThread())
                throw new IllegalMonitorStateException();
            boolean free = false;
            //如果是 0，那么表示当前线程完全退出包括重入的所有锁，可以释放锁。
            if (c == 0) {
                free = true;
                setExclusiveOwnerThread(null);
            }
            setState(c);
            return free;
        }
    
        /**
         * 检查锁是否被当前线程持有。
         */
        protected final boolean isHeldExclusively() {
            //通常情况下不需要用这种方式判断是否是当前线程持有锁
            return getExclusiveOwnerThread() == Thread.currentThread();
        }
    
        /**
         * 创建竞态条件
         */
        final ConditionObject newCondition() {
            return new ConditionObject();
        }
    
        // Methods relayed from outer class
    
        final Thread getOwner() {
            return getState() == 0 ? null : getExclusiveOwnerThread();
        }
    
        final int getHoldCount() {
            return isHeldExclusively() ? getState() : 0;
        }
    
        /**
         * 检查同步器是否上锁。如果未上锁，那么也表示当前线程未持有锁
         */
        final boolean isLocked() {
            return getState() != 0;
        }
    
        /**
         * 未被使用。可能是为序列化提供重置锁的状态
         */
        private void readObject(java.io.ObjectInputStream s)
            throws java.io.IOException, ClassNotFoundException {
            s.defaultReadObject();
            //将同步器的状态置为未上锁
            setState(0);
        }
    }
    ```

Sync 类是一个抽象类，ReentrantLock 并不会直接使用 Sync 类对象，而是使用它的子类 NonfairSync-非公平锁和 FairSync-公平锁。Sync 类定义了许多公共的不可重写的方法，比如同步器是否上锁等，获取当前持有锁的线程对象，创建一个新的竞态条件等。

NonfairSync 类主要是实现上锁的抽象方法(lock)以及获取锁（tryAcquire)，代码如下：

    ```java
    /**
     * 非公平锁策略实现的上锁
     */
    static final class NonfairSync extends Sync {
        private static final long serialVersionUID = 7316153563782823691L;
    
        /**
         * 上锁
         * 通过 CAS 修改方式快速上锁。如果 CAS 方式上锁失败，那么通过普通的获取锁的方式上锁。
         */
        final void lock() {
            if (compareAndSetState(0, 1))
                setExclusiveOwnerThread(Thread.currentThread());
            else
                acquire(1);
        }
    
        /**
         * 获取锁。使用的是 Sync 类的 nonfairTryAcquire 获取锁
         */
        protected final boolean tryAcquire(int acquires) {
            return nonfairTryAcquire(acquires);
        }
    }
    ```

FairSync 类主要实现抽象类中上锁的方法，代码如下：

    ```java
    /**
     * 公平锁策略实现上锁
     */
    static final class FairSync extends Sync {
        private static final long serialVersionUID = -3000897897090466540L;
    
        final void lock() {
            acquire(1);
        }
    
        /**
         * 利用公平锁的策略实现获取锁
         * 利用 AbstractQueuedSynchronizer 提供 hasQueuedPredecessors 方法，来判断等待队列中是否有排队获取锁的元素，
         * 如果有则加到队列尾部并将线程挂起，如此来实现公平锁策略。
         */
        protected final boolean tryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            //如果当前状态是 0，表示未上锁
            if (c == 0) {
                //判断等待队列是否有非当前线程持有的元素。
                //为了避免并发问题，使用 CAS 的方式修改状态
                if (!hasQueuedPredecessors() &&
                    compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            //如果不为 0，那么看是否是当前线程重入导致的，即当前线程已经持有过锁。如果持有过锁，那么表示锁重入，持有锁成功。
            else if (current == getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if (nextc < 0)
                    throw new Error("Maximum lock count exceeded");
                setState(nextc);
                return true;
            }
            return false;
        }
    }

    public class ReentrantLock implements Lock, java.io.Serializable {
      private static final long serialVersionUID = 7373984872572414699L;
      //同步器
      private final Sync sync;
    
      /**
       * 重入锁的无参构造函数
       * 默认初始化一个非公平锁策略的同步器。
       */
      public ReentrantLock() {
          sync = new NonfairSync();
      }
    
      /**
       * 根据指定的参数选择公平策略还是非公平策略的同步器。
       * 如果是 true 表示公平锁，如果是 false 非公平锁。
       *
       * @param fair {@code true} if this lock should use a fair ordering policy
       */
      public ReentrantLock(boolean fair) {
          sync = fair ? new FairSync() : new NonfairSync();
      }
    
      /**
       * 上锁
       * 如果同步器没有被其他线程持有，那么立刻上锁，将 state 从 0 改成 1，并立刻返回。
       * 如果当前线程已经持有锁，那么 state 的值加一，并立即返回上锁成功。
       * 如果同步器被其他线程持有，那么当前线程被挂起，并生成一个元素绑定当前线程。
       * 元素被加入到等待队列中，等待前一个元素释放锁后被唤醒。
       */
      public void lock() {
          sync.lock();
      }
    
      /**
       * 上锁。
       * 和 lock()的区别是能够响应线程中断。如果线程被中断，那么抛出 InterruptedException 异常
       */
      public void lockInterruptibly() throws InterruptedException {
          sync.acquireInterruptibly(1);
      }
    
      /**
       * 尝试获取锁。
       * 如果获取不到锁，线程不会被挂起，而是返回 false。能够获取到则返回 true
       *
       * @return {@code true} if the lock was free and was acquired by the
       *         current thread, or the lock was already held by the current
       *         thread; and {@code false} otherwise
       */
      public boolean tryLock() {
          return sync.nonfairTryAcquire(1);
      }
    
      /**
       * 上锁
       * 和 tryLock()方法相比，增加响应线程中断的处理和等待超时的时间。
       *
       * @param timeout the time to wait for the lock
       * @param unit the time unit of the timeout argument
       * @return {@code true} if the lock was free and was acquired by the
       *         current thread, or the lock was already held by the current
       *         thread; and {@code false} if the waiting time elapsed before
       *         the lock could be acquired
       * @throws InterruptedException if the current thread is interrupted
       * @throws NullPointerException if the time unit is null
       */
      public boolean tryLock(long timeout, TimeUnit unit)
              throws InterruptedException {
          return sync.tryAcquireNanos(1, unit.toNanos(timeout));
      }
    
      /**
       * 释放锁
       * 如果当前线程持有锁，那么 state 状态的值减一。如果 state 变更后成 0，那么将同步器的线程置为 Null。
       * 如果持有同步器的线程不是当前线程，那么抛出 IllegalMonitorStateException 异常。
       *
       * @throws IllegalMonitorStateException if the current thread does not
       *         hold this lock
       */
      public void unlock() {
          sync.release(1);
      }
    
      /**
       * 创建一个新的竞态条件。使用的类是 AbstractQueuedSynchronizer.ConditionObject
       *
       * @return the Condition object
       */
      public Condition newCondition() {
          return sync.newCondition();
      }
    
      /**
       * 获取当前线程重入锁的次数。
       * 如果同步器不是当前线程持有，那么返回 0。
       * 通常情况下不需要使用这个方法，该方法一般用于测试和调试，查看当下这个线程的重入次数。
       *
       * @return the number of holds on this lock by the current thread,
       *         or zero if this lock is not held by the current thread
       */
      public int getHoldCount() {
          return sync.getHoldCount();
      }
    
      /**
       * 当前线程是否持有锁。和 getHoldCount 类似，一般也是用于测试和调试。
       *
       * @return {@code true} if current thread holds this lock and
       *         {@code false} otherwise
       */
      public boolean isHeldByCurrentThread() {
          return sync.isHeldExclusively();
      }
    
      /**
       * 获取同步器是否被上锁的信息。true 表示被某个线程持有锁，否则返回 false。
       * 这个接口用于监控等作用，同步器本身并没有使用该方法。
       *
       * @return {@code true} if any thread holds this lock and
       *         {@code false} otherwise
       */
      public boolean isLocked() {
          return sync.isLocked();
      }
    
      /**
       * 获取同步策略。true 表示公平锁；false 表示非公平锁
       *
       * @return {@code true} if this lock has fairness set true
       */
      public final boolean isFair() {
          return sync instanceof FairSync;
      }
    
      /**
       * Returns the thread that currently owns this lock, or
       * {@code null} if not owned. When this method is called by a
       * thread that is not the owner, the return value reflects a
       * best-effort approximation of current lock status. For example,
       * the owner may be momentarily {@code null} even if there are
       * threads trying to acquire the lock but have not yet done so.
       * This method is designed to facilitate construction of
       * subclasses that provide more extensive lock monitoring
       * facilities.
       * 返回持有同步器的线程对象，如果没有任何线程持有同步器则返回 null。
       * 如果有线程在获取锁中但是还未获取到锁，该方法依然返回 null。
       * 该方法用来给子类提供高效的锁监听工具。
       *
       * @return the owner, or {@code null} if not owned
       */
      protected Thread getOwner() {
          return sync.getOwner();
      }
    
      /**
       * 判断等待队列中是否有线程。
       * 不包括正在获取锁的线程。一般用于监控系统状态。
       *
       * @return {@code true} if there may be other threads waiting to
       *         acquire the lock
       */
      public final boolean hasQueuedThreads() {
          return sync.hasQueuedThreads();
      }
    
      /**
       * 查找指定的线程是否在队列中。
       * 如果给定的 thread 是 null，抛出空指针异常。
       *
       * @param thread the thread
       * @return {@code true} if the given thread is queued waiting for this lock
       * @throws NullPointerException if the thread is null
       */
      public final boolean hasQueuedThread(Thread thread) {
          return sync.isQueued(thread);
      }
    
      /**
       * 返回等待线程的数量。一般用于监控
       *
       * @return the estimated number of threads waiting for this lock
       */
      public final int getQueueLength() {
          return sync.getQueueLength();
      }
    
      /**
       * 返回等待线程的集合。一般用于监控
       *
       * @return the collection of threads
       */
      protected Collection<Thread> getQueuedThreads() {
          return sync.getQueuedThreads();
      }
    
      /**
       * 查找是否有线程在等待给定的竞态条件。一般用于监控
       *
       * @param condition the condition
       * @return {@code true} if there are any waiting threads
       * @throws IllegalMonitorStateException if this lock is not held
       * @throws IllegalArgumentException if the given condition is
       *         not associated with this lock
       * @throws NullPointerException if the condition is null
       */
      public boolean hasWaiters(Condition condition) {
          if (condition == null)
              throw new NullPointerException();
          if (!(condition instanceof AbstractQueuedSynchronizer.ConditionObject))
              throw new IllegalArgumentException("not owner");
          return sync.hasWaiters((AbstractQueuedSynchronizer.ConditionObject)condition);
      }
    ```

<a id="orgd0a0f2d"></a>

# ReadWriteLock

ReadWriteLock 是定义读写锁功能的接口，位于 java.util.concurrent.locks 包下。

ReadWriteLock 主要定义了返回读锁和返回写锁，代码如下：

    ```java
    public interface ReadWriteLock {
        /**
         * Returns the lock used for reading.
         *
         * @return the lock used for reading
         */
        Lock readLock();
    
        /**
         * Returns the lock used for writing.
         *
         * @return the lock used for writing
         */
        Lock writeLock();
    }
    ```

ReadWriteLock 顾名思义提供读锁和写锁。读锁允许多个线程同时持有并访问资源，并在所有线程都释放读锁后才允许写锁访问和修改共享资源。写锁是独占锁，具有排他性。即只允许一个线程访问和修改资源，其他线程不论是持有读锁还是写锁，都必须等待当前的写锁释放后才能访问共享资源。

ReadWriteLock 的实现类需要子类保证读写锁内存同步，即获取到读锁的线程能够看到之前释放的写锁的操作后的结果。

由于读写锁允许多个线程同时访问共享资源，只允许一个线程修改共享资源，所以通常情况下比独占锁提供更高的并发性能。这不是指读写锁的并发性能一定比 synchronized 关键词控制共享资源的并发性能高。因为 synchronized 字段不是简单地提供一个独占锁，事实上和读写锁的大部分具体实现类一样，synchronized 是一个可重入锁。并且 synchronized 事实上提供 3 种锁：

-   偏向锁：Java 6 提供的功能，当有线程第一次访问 synchronize 保护的共享资源时，此时不加系统的互斥锁（Mutex Lock），只是改变内存中类对象的标志位信息（Mark Word）。
-   轻量级锁：如果有其他的线程进入 synchronized 保护的共享资源，那么锁升级为轻量级锁，此时依然不使用系统的互斥锁，而是通过 CAS 的方式改变对象的标志位信息，如果成功，线程继续访问受保护资源。
-   重量级锁：如果轻量级锁使用 CAS 方式修改对象头的标志位信息失败，那么使用系统的互斥锁挂起当前线程，等待上一个使用轻量级锁的线程退出共享资源后唤醒。

synchronized 更加多的优化内容请阅读《深入理解 Java 虚拟机》和《java 并发编程实战》关于锁的优化的章节。

鉴于 synchronized 拥有强大的功能但是使用上又如此简单，所以并不建议一定使用读写锁代替 synchronized。但是读写锁拥有 synchronized 没有其他强大的功能，如果需要这些功能的场景下，我们可以选择读写锁。

-   可以中断等待获取锁的线程
-   可以设置等待获取锁的超时时间
-   可以保证顺序
-   可以允许多个线程同时获取锁

读写锁的和系统独占锁（非 synchronized 而是指系统的 Mutex Lock）的性能高低比较依赖共享数据的使用场景：读写数据的频率；读写数据的时长；读写数据时线程争用情况（同一时刻多少个线程同时读取和多少个线程同时写入）。在写入很少但是读取很频繁的情况下读写锁的性能要优于独占锁。但是如果写入很频繁，基于同步器实现的锁处理方式是，写入线程和后续的读线程会被串行化（具体情况比简单的串行化更加复杂），并且未获取到锁的线程会被挂起(LockSupport.park)，可以简单的理解为使用 Mutex Lock 实现。这种情况下，还不如直接使用系统独占锁来的性能高。synchronized 中的轻量级锁和重量级锁的性能比较也是类似。

读写锁还需要结合使用场景考虑一些实现策略，这些策略可能会影响读写锁的性能：

1.  如果同时又读线程和写线程，那么当前写线程释放资源时，资源的控制权交给读线程还是写线程？通常情况下会交给写线程，因为通常情况下写操作频率低并且执行时间短。如果交给读线程，那么由于读线程很频繁，写线程可能需要等待很长的时间。当然也可以实现公平锁，按照先来先得的方式分配共享资源。
2.  如果当前读线程正在访问共享资源，持有共享资源的锁，同时有一个写线程在等待获取共享资源的锁，此时有许多读线程尝试获取共享资源的锁，那么此时这些读线程是立刻获取到共享资源的读锁还是等待写线程结束后再获取到共享资源的锁。
3.  如果线程已经获取写锁了，那么在持有写锁期间，能否获取读锁。
4.  写锁和读锁之间能够单向或双向转换吗？


<a id="orgc616c40"></a>

# ReentrantReadWriteLock

ReentrantReadWriteLock 实现了 ReadWriteLock（读写锁接口）和可重入锁的两种特性，可以提供

1.  按顺序获取锁
    不是按照读优先或者写优先，而是提供一种公平获取锁的策略。
    非公平策略：如果利用非公平策略构建 ReentrantReadWriteLock，那么获取读锁的线程和获取写锁的线程获取到锁的顺序是随机的，受可重入次数限制。非公平锁可能会不断延迟竞争中的其他尝试获取读锁和写锁的线程（一次只有一个线程获取锁，读锁需要等一个读线程获取锁后，其他读线程才能够获取锁），但是通常来说比公平策略有更高的并发性能。
    公平策略：如果利用公平策略构建 ReentrantReadWriteLock，那么线程获取锁的顺序近似先到先得（在竞争锁的过程中，由于线程执行受操作系统线程调度影响，可能会导致后进入获取锁代码块的线程先获得锁）。当线程释放锁后，等待最长的当个写线程获取到写锁，或者等待最长的一组读线程获取到读锁。
    除非没有其他线程获取锁，否则公平策略下获取写锁将会被阻塞。ReentrantReadWriteLock.ReadLock.tryLock() 和 ReentrantReadWriteLock.WriteLock.tryLock()两个方法不考虑公平策略原则，如果可以获取锁，则直接返回 true。
2.  线程可再次获取锁
    在可重入锁中，锁允许被读线程和写线程再次获取。在写线程持有锁时，除非写线程释放锁，否则不允许读线程重入。
    在线程获取写锁后，允许再次获取读锁，但是不允许线程获取写锁后再获取写锁。如果线程调用的方法需要上写锁，但是方法调用其他的方法或者回调方法中又需要上读锁，这种情况下锁的可重入就非常有用。如果已经持有读锁，那么重入写锁时将会失败。
3.  锁降级
    可重入性质允许线持有读锁进而获取读锁时通过先释放写锁再上读锁的方式做锁的降级。但是不允许一个读锁升级为写锁。
4.  响应线程中断
    不过上上读锁还是上写锁，在获取锁的过程中都会响应线程中断。
5.  支持竞态条件
    竞态条件和可重入锁（ReentrantLock.newCondition）提供的竞态条件功能类似，也和写锁的表现形式类似。只有写锁才支持竞态条件，如果读锁条用创建竞态条件的方法会抛出 UnsupportedOperationException 异常。
6.  监控方法
    ReentrantReadWriteLock 提供了许多查看同步器状态的方法，可以来做做监控系统。

使用的例子如下：

    ```java
     class CachedData {
      Object data;
      volatile boolean cacheValid;
      final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
    
      void processCachedData() {
        //方法第一句先上锁，再做业务操作
        rwl.readLock().lock();
        if (!cacheValid) {
          // 如果数据没有被换粗，则需要改变数据。这时需要释放读锁，并加上写锁。
          rwl.readLock().unlock();
          rwl.writeLock().lock();
          try {
            // 上完写锁后我们需要再次做检查。因为可能其他的写锁做了这个实行。
            if (!cacheValid) {
              data = ...
              cacheValid = true;
            }
            //通过线程持有写锁的情况下，再次获取读锁来降级
            rwl.readLock().lock();
          } finally {
            //此时的写锁已经被降级为读锁，通过这个方式将会把锁释放掉。
            rwl.writeLock().unlock();
          }
        }
    
        try {
          use(data);
        } finally {
          rwl.readLock().unlock();
        }
      }
    }
    ```

ReentrantReadWriteLocks 通常用来改善使用集合类的并发情况。这些集合的使用场景通常是数据量比较大，并且遍历或者查找数据的比例远远大于更改数据的比例。这种情况下的使用例子如下：

    ```java
     class RWDictionary {
      private final Map<String, Data> m = new TreeMap<String, Data>();
      private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
      private final Lock r = rwl.readLock();
      private final Lock w = rwl.writeLock();
    
      public Data get(String key) {
        r.lock();
        try { return m.get(key); }
        finally { r.unlock(); }
      }
      public String[] allKeys() {
        r.lock();
        try { return m.keySet().toArray(); }
        finally { r.unlock(); }
      }
      public Data put(String key, Data value) {
        w.lock();
        try { return m.put(key, value); }
        finally { w.unlock(); }
      }
      public void clear() {
        w.lock();
        try { m.clear(); }
        finally { w.unlock(); }
      }
    }
    ```

ReentrantReadWriteLocks 支持的可重入次数为 65535，如果超过这个次数抛出 Error。比 ReentrantLock 重入次数少的 2 次方的数量是因为 state 的高 16 位-1 来表示读锁的重入次数，低 16 位-1 来表示写锁的重入次数。

ReentrantReadWriteLock 内置了一个同步器的对象 Sync，提供获取锁释放锁的诸多实现。Sync 代码如下：

    ```java
    /**
     * 同步器，实现 AbstractQueuedSynchronizer 抽象方法比如 tryRelease，tryAcquire 等。
     */
    abstract static class Sync extends AbstractQueuedSynchronizer {
        private static final long serialVersionUID = 6317671515068378041L;
    
        /**
         * 在 ReentrantLock 中，线程持有的读写锁的次数通过同步器的 state 来表示。
         * 在 ReentrantReadWriteLock 中，state（int 类型）被分成两个部分，高 16 位表示持有读锁次数，低 16 为表示写锁次数。
         * SHARED_SHIFT = 16 用来做高低位次数的计算。
         */
        static final int SHARED_SHIFT   = 16;
        /**
         * 用于增加读锁持有数量。由于读锁使用高 16 位表示，所以每次持有锁时，增加的 1+SHARED_UNIT。
         */
        static final int SHARED_UNIT    = (1 << SHARED_SHIFT);
        /**
         * 持有锁的上限
         */
        static final int MAX_COUNT      = (1 << SHARED_SHIFT) - 1;
        /**
         * 写锁的上限
         */
        static final int EXCLUSIVE_MASK = (1 << SHARED_SHIFT) - 1;
    
        /**
         * 读锁的持有数量。由于使用完整的 32 位(普通 int 类型最高位是符号位)表示读写锁的持有数量，所以使用无符号右移。
         */
        static int sharedCount(int c)    { return c >>> SHARED_SHIFT; }
        /**
         * 写锁的持有数量
         */
        static int exclusiveCount(int c) { return c & EXCLUSIVE_MASK; }
    
        /**
         * 线程获取锁的次数。这个数据通过 ThreadLocal 保存在线程的内存中。
         * 同步器（Sync）通过属性 cachedHoldCounter 指向当前线程的持有次数
         */
        static final class HoldCounter {
            int count = 0;
            // Use id, not reference, to avoid garbage retention
            final long tid = getThreadId(Thread.currentThread());
        }
    
        /**
         * 为了方便反序列化而定义结构。
         */
        static final class ThreadLocalHoldCounter
            extends ThreadLocal<HoldCounter> {
            public HoldCounter initialValue() {
                return new HoldCounter();
            }
        }
    
        /**
         * 当前线程读锁的重入次数。如果当前线程读锁释放完毕后，从线程内存中删除这部分的数据（ThreadLocal.remove）。
         */
        private transient ThreadLocalHoldCounter readHolds;
    
        /**
         * 保存线程重入次数。这个数据存储在 TreadLocal 中。
         * 由于是存储在线程内存中，所以生命周期和绑定的线程相同。由于使用了 transient 关键词修饰，所以无法序列化。
         * 由于数据存放在当前线程内存中，保证了数据并发情况下的安全性。
         */
        private transient HoldCounter cachedHoldCounter;
    
        /**
         * firstReader 是第一个获取读锁的线程的引用。
         * 并不一定有多个线程同时获取读锁的情况，如果只有一个线程获取读锁，那么不需要开辟线程内存存储重入次数。
         */
        private transient Thread firstReader = null;
        /**
         * 第一个获取读锁的线程重入次数。
         * 原因同 firstReader。
         */
        private transient int firstReaderHoldCount;
    
        Sync() {
            readHolds = new ThreadLocalHoldCounter();
            setState(getState()); // ensures visibility of readHolds
        }
    
        /**
         * 如果获取读锁需要等待，返回 true；否则返回 false。
         * 如果是公平策略，那么读锁需要等待，如果是非公平策略，读锁不需要等待。
         * 交给公平锁和非公平锁子类实现。
         */
        abstract boolean readerShouldBlock();
    
        /**
         * 如果获取写锁需要等待，那么返回 true；否则返回 false。同 readerShouldBlock
         */
        abstract boolean writerShouldBlock();
    
        /*
         * 释放独占锁。
         */
        protected final boolean tryRelease(int releases) {
            //需要是当前线程持有同步器才能操作，否则抛出异常
            if (!isHeldExclusively())
                throw new IllegalMonitorStateException();
            int nextc = getState() - releases;
            boolean free = exclusiveCount(nextc) == 0;
            if (free)
                setExclusiveOwnerThread(null);
            setState(nextc);
            return free;
        }
    
        /**
         * 获取独占锁
         * 如果读锁和写锁的重入次数不为 0，并且同步器的绑定的线程和当前线程并非同一个线程，获取锁会失败
         * 如果超过重入次数限制，那么获取锁会失败
         *
         */
        protected final boolean tryAcquire(int acquires) {
            Thread current = Thread.currentThread();
            int c = getState();
            //写锁重入次数
            int w = exclusiveCount(c);
            if (c != 0) {
                // c != 0 但是写锁重入次数为 0，说明读锁的重入次数不为 0，读锁还未释放，写锁获取失败。
                if (w == 0 || current != getExclusiveOwnerThread())
                    return false;
                //超过重入次数，获取锁失败
                if (w + exclusiveCount(acquires) > MAX_COUNT)
                    throw new Error("Maximum lock count exceeded");
                //成功获取锁，更新 state 的值
                setState(c + acquires);
                return true;
            }
            //c == 0 表示未有线程获取过读锁和写锁。
            //writerShouldBlock 由具体子类的选择的公平策略实现，判断获取锁是否成功
            if (writerShouldBlock() ||
                !compareAndSetState(c, c + acquires))
                return false;
            setExclusiveOwnerThread(current);
            return true;
        }
    
        /**
         * 释放共享锁
         */
        protected final boolean tryReleaseShared(int unused) {
            Thread current = Thread.currentThread();
            //如果当前线程和 firstReader 指向的线程是同一个线程，那么当前线程没有开辟 ThreadLocal 用于保存重入次数，
            //而是使用 firstReaderHoldCount 保存重入次数。
            if (firstReader == current) {
                // assert firstReaderHoldCount > 0;
                if (firstReaderHoldCount == 1)
                    firstReader = null;
                else
                    firstReaderHoldCount--;
            } else {
                HoldCounter rh = cachedHoldCounter;
                /**
                 * 如果当前线程和 firstReader 中指向的线程不一致，那么获取缓存中的线程重入次数，
                 * 比较线程编号是否一致（是否是同一个线程）。如果不一致则冲线程内存中获取重入次数
                 */
                if (rh == null || rh.tid != getThreadId(current))
                    rh = readHolds.get();
                int count = rh.count;
                if (count <= 1) {
                    readHolds.remove();
                    if (count <= 0)
                        throw unmatchedUnlockException();
                }
                --rh.count;
            }
            /**
             * 利用 CAS 方式改变锁的重入次数。如果更改失败，则通过自旋的方式知道更改成功
             */
            for (;;) {
                int c = getState();
                //使用高 16 位表示，所以需要减去 SHARED_UNIT 常量
                int nextc = c - SHARED_UNIT;
                if (compareAndSetState(c, nextc))
                    /**
                     * 如果 nextc 不为 0，表示当前线程还是持有读锁或者写锁。
                     * AbstractQueuedSynchronizer 的 releaseShared 方法（释放共享锁），
                     * 先调用 tryReleaseShared，如果返回 true,则执行 doReleaseShared()，唤醒等待队列中后续的线程。
                     * 由于可重入，所以必须要等到当前线程释放所有读锁和写锁后才会返回 true（线程释放锁）。
                     */
                    return nextc == 0;
            }
        }
    
        /**
         * 获取共享锁
         */
        protected final int tryAcquireShared(int unused) {
            Thread current = Thread.currentThread();
            int c = getState();
            //如果其他线程获取了写锁，那么当前线程无法获取共享锁
            if (exclusiveCount(c) != 0 &&
                getExclusiveOwnerThread() != current)
                return -1;
            int r = sharedCount(c);
            //如果线程的重入次数未达到上限，并且获取锁不需要阻塞（公平策略和非公平策略实现的逻辑不一样），
            //则通过 CAS 方式更新 state 的内容。
            if (!readerShouldBlock() &&
                r < MAX_COUNT &&
                compareAndSetState(c, c + SHARED_UNIT)) {
                //更新重入次数
                if (r == 0) {
                    firstReader = current;
                    firstReaderHoldCount = 1;
                } else if (firstReader == current) {
                    firstReaderHoldCount++;
                } else {
                    HoldCounter rh = cachedHoldCounter;
                    if (rh == null || rh.tid != getThreadId(current))
                        cachedHoldCounter = rh = readHolds.get();
                    else if (rh.count == 0)
                        readHolds.set(rh);
                    rh.count++;
                }
                return 1;
            }
            /**
             * 如果线程释放锁需要被阻塞，或者 CAS 更新失败，或者超过上限，那么调用 fullTryAcquireShared 获取锁
             */
            return fullTryAcquireShared(current);
        }
    
        /**
         * 利用自旋的方式不断尝试去获取锁知道成功或者失败。
         *
         */
        final int fullTryAcquireShared(Thread current) {
            /*
             * This code is in part redundant with that in
             * tryAcquireShared but is simpler overall by not
             * complicating tryAcquireShared with interactions between
             * retries and lazily reading hold counts.
             */
            HoldCounter rh = null;
            //自旋获取锁
            for (;;) {
                int c = getState();
                //如果同步器指向的线程不是当前线程，则直接失败。
                if (exclusiveCount(c) != 0) {
                    /**
                     * 用来避免某些情况下发生死锁，比如当前线程先获取了写锁并且未释放锁，其他线程后续获取写锁并到等待队列中等待，
                     * 此时当前线程又获取了读锁。如果没有 getExclusiveOwnerThread() != current 的条件，
                     * 那么获取读锁失败，当前线程在没有释放写锁并唤醒后续等待队列的情况下，进入等待队列队尾并将当前线程挂起。
                     * 此时后续写线程正在等待队列中等待当前线程唤醒，但是当前线程又进入到等待队列队尾并挂起，等待其他线程唤醒。
                     * 两个线程都是挂起等待对方唤醒的状态，造成线程死锁。
                     * tryAcquireShared 返回-1 后，执行 doAcquireShared 方法进入等待队列并阻塞当前线程。
                     */
                    if (getExclusiveOwnerThread() != current)
                        return -1;
                } else if (readerShouldBlock()) {
                    // 如果读锁应该被锁定，并且并非是线程重入的话，那么获取锁失败返回-1。
                    if (firstReader == current) {
                        // firstReader == current 表示本次获取锁时重入。
                    } else {
                        if (rh == null) {
                            rh = cachedHoldCounter;
                            if (rh == null || rh.tid != getThreadId(current)) {
                                rh = readHolds.get();
                                if (rh.count == 0)
                                    readHolds.remove();
                            }
                        }
                        //rh.count == 0 表示当前线程第一次获取锁，但是由于触发读锁应该被阻塞，所以获取锁失败。
                        if (rh.count == 0)
                            return -1;
                    }
                }
                //超过重入次数
                if (sharedCount(c) == MAX_COUNT)
                    throw new Error("Maximum lock count exceeded");
                //利用 CAS 方式修改锁重入次数的值。由于是在 for(;;)循环体中，如果 CAS 更新失败会不断执行 CAS 更新直到成功
                if (compareAndSetState(c, c + SHARED_UNIT)) {
                    //如果读锁在获取锁之前状态是 0，表示读锁第一次被线程获取，
                    //那么更新同步器的 firstReader 和 firstReaderHoldCount 的值
                    if (sharedCount(c) == 0) {
                        firstReader = current;
                        firstReaderHoldCount = 1;
                    //如果 firstReader 指向的线程和当前线程一致，那么只需要更新 firstReaderHoldCount
                    } else if (firstReader == current) {
                        firstReaderHoldCount++;
                    //否则更新 cachedHoldCounter（最后获取读锁的线程同步次数），并将重入次数添加到线程内存中。
                    } else {
                        if (rh == null)
                            rh = cachedHoldCounter;
                        if (rh == null || rh.tid != getThreadId(current))
                            rh = readHolds.get();
                        else if (rh.count == 0)
                            readHolds.set(rh);
                        rh.count++;
                        cachedHoldCounter = rh;
                    }
                    return 1;
                }
            }
        }
    
        /**
         * 和 tryLock 方法类似，尝试获取锁，如果获取失败不会阻塞直接返回 false。
         */
        final boolean tryWriteLock() {
            Thread current = Thread.currentThread();
            int c = getState();
            //c != 0 表示已经有线程获取过读锁或者写锁。
            if (c != 0) {
                //写锁的重入次数
                int w = exclusiveCount(c);
                //如果写锁未被获取过，并且
                if (w == 0 || current != getExclusiveOwnerThread())
                    return false;
                if (w == MAX_COUNT)
                    throw new Error("Maximum lock count exceeded");
            }
            //如果 CAS 更新失败则立刻返回 false，表示获取锁失败
            if (!compareAndSetState(c, c + 1))
                return false;
            //如果更新成功，将同步器的指向的线程指向当前线程
            setExclusiveOwnerThread(current);
            return true;
        }
    
        /**
         * 和 tryLock 方法类似，获取锁，如果失败不会阻塞当前线程，直接返回 false。
         */
        final boolean tryReadLock() {
            Thread current = Thread.currentThread();
            //如果 CAS 更新失败，那么自旋知道更新成功或者获取锁失败。
            for (;;) {
                int c = getState();
                //如果同步器指向的线程不是当前线程并且已经有线程获取过写锁，那么读锁获取失败。
                if (exclusiveCount(c) != 0 &&
                    getExclusiveOwnerThread() != current)
                    return false;
                int r = sharedCount(c);
                //超过重入次数则抛出异常
                if (r == MAX_COUNT)
                    throw new Error("Maximum lock count exceeded");
                //CAS 方式修改 state，如果失败则自旋
                if (compareAndSetState(c, c + SHARED_UNIT)) {
                    //r == 0 表示当前线程是第一个获取读锁的线程，更新 firstReader 和 firstReaderHoldCount
                    if (r == 0) {
                        firstReader = current;
                        firstReaderHoldCount = 1;
                    //firstReader == current 表示当前线程是第一次获取读锁的线程，
                    //并且重入获取读锁只更新 firstReaderHoldCount
                    } else if (firstReader == current) {
                        firstReaderHoldCount++;
                    } else {
                        //否则更新 cachedHoldCounter
                        HoldCounter rh = cachedHoldCounter;
                        if (rh == null || rh.tid != getThreadId(current))
                            cachedHoldCounter = rh = readHolds.get();
                        else if (rh.count == 0)
                            readHolds.set(rh);
                        rh.count++;
                    }
                    return true;
                }
            }
        }
    }
    ```

Sync 是一个同步器，继承自 AbstractQueuedSynchronizer。主要实现了以下内容：

1.  实现了 AbstractQueuedSynchronizer 定义但未实现的方法，比如 tryAcquire，tryRelease，tryAcquireShared，tryReleaseShared，isHeldExclusively 等。
2.  获取锁时给同步策略和非同步策略留出自定义的空间(readerShouldBlock，writerShouldBlock 方法)，方便子类实现公平和非公平策略。
3.  提供一些同步器状态信息的方法，比如：获取同步器指向的线程（getOwner），获取读锁的重入次数（getReadLockCount）等。

NonfairSync（非公平策略同步器）定义了非公平策略实现writerShouldBlock和readerShouldBlock的方式。具体代码如下：

    ```java
    static final class NonfairSync extends Sync {
    
          //写锁直接返回false，不需要阻塞。
          final boolean writerShouldBlock() {
              return false; // writers can always barge
          }
          /**
           * 如果队列中第一个线程等待线程获取的是独占锁，那么获取读锁需要阻塞
           */
          final boolean readerShouldBlock() {
              return apparentlyFirstQueuedIsExclusive();
          }
      }
    ```

FairSync（公平策略同步器）定义了公平策略实现writerShouldBlock和readerShouldBlock的方式。具体代码如下：

    ```java
    static final class FairSync extends Sync {
          //如果等待队列中有等待线程，那么需要阻塞。
          final boolean writerShouldBlock() {
              return hasQueuedPredecessors();
          }
          //如果等待队列中有等待线程，那么需要阻塞。
          final boolean readerShouldBlock() {
              return hasQueuedPredecessors();
          }
    }
    ```

ReentrantReadWriteLock内部还有两个内部类，分别是ReadLock和WriteLock，用于提供读写锁的上锁和释放锁的功能。

ReadLock代码如下：

    ```java
    /**
     * 读锁的实现类，对外提供读锁的获取锁，上锁和释放锁等功能
     */
    public static class ReadLock implements Lock, java.io.Serializable {
        private static final long serialVersionUID = -5992448646407690164L;
        private final Sync sync;
    
        /**
         * 使用的是ReentrantReadWriteLock内部类Sync实现的上锁和释放锁。
         * Sync在ReentrantReadWriteLock初始化时会指定是使用的是公平策略还是非公平策略。
         *
         * @param lock the outer lock object
         * @throws NullPointerException if the lock is null
         */
        protected ReadLock(ReentrantReadWriteLock lock) {
            sync = lock.sync;
        }
    
        /**
         * 获取读锁
         * 如果其他线程没有获取过写锁的话，那么立即返回获取锁成功。
         * 如果其他线程获取过写锁，如果是公平策略，那么线程挂起知道通知唤醒；
         * 如果是非公平策略，那么看队列中第一个等待线程是否是写锁，如果是写锁则挂起直到通知唤醒，否则成功获取锁。
         */
        public void lock() {
            sync.acquireShared(1);
        }
    
        /**
         * 获取读锁
         * 和lock()类似，不同的地方在于如果获取锁过程中包括线程挂起期间，当前线程能够响应线程中断。
         * 如果线程被中断（抛出InterruptedException），当前线程的中断状态会被清除。
         *
         * @throws InterruptedException if the current thread is interrupted
         */
        public void lockInterruptibly() throws InterruptedException {
            sync.acquireSharedInterruptibly(1);
        }
    
        /**
         * 尝试获取读锁。
         * 如果获取失败，立即返回false，当前线程不会被挂起。这个方法会忽略公平和非公平策略。
         *
         * @return {@code true} if the read lock was acquired
         */
        public boolean tryLock() {
            return sync.tryReadLock();
        }
    
        /**
         * 获取读锁。
         * 如果其他线程获取过写锁，并且当前线程未被中断，那么当前线程会被挂起，知道等待时间结束。
         * 该方法使用公平和非公平策略。
         * 该方法呢能够响应线程中断。并且如果是线程中断，抛出InterruptedException，线程的撞断状态被清除。
         *
         * @param timeout the time to wait for the read lock
         * @param unit the time unit of the timeout argument
         * @return {@code true} if the read lock was acquired
         * @throws InterruptedException if the current thread is interrupted
         * @throws NullPointerException if the time unit is null
         */
        public boolean tryLock(long timeout, TimeUnit unit)
                throws InterruptedException {
            return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));
        }
    
        /**
         * 释放锁
         * 由于可能是线程重入，所以尽管当前线程使用了unlock，但是当前线程依然可能持有读锁。
         */
        public void unlock() {
            sync.releaseShared(1);
        }
    
        /**
         * 读锁不支持竞态条件
         *
         * @throws UnsupportedOperationException always
         */
        public Condition newCondition() {
            throw new UnsupportedOperationException();
        }
    }
    ```

WriteLock代码如下：

    ```java
    public static class WriteLock implements Lock, java.io.Serializable {
          private static final long serialVersionUID = -4992448646407690164L;
          private final Sync sync;
    
          /**
           * 使用ReentrantReadWriteLock中的公平非公平策略
           *
           * @param lock the outer lock object
           * @throws NullPointerException if the lock is null
           */
          protected WriteLock(ReentrantReadWriteLock lock) {
              sync = lock.sync;
          }
    
          /**
           * 获取写锁
           * 如果未有任何线程获取过写锁，那么获取锁成功，并将线程持有锁的次数设置为1
           * 如果当前线程是重入获取写锁，持有次数加1
           * 如果其他线程已经持有过写锁，那么如果是公平策略，线程挂起知道被唤醒；
           * 如果是非公平策略，CAS修改同步器的state，成功则获取锁，失败则线程挂起，知道唤醒
           */
          public void lock() {
              sync.acquire(1);
          }
    
          /**
           * 获取写锁。
           * 和lock()类似，不同在于lock()方法无法响应中断，但是lockInterruptibly可以响应线程中断。
           * 如果线程在等待获取锁的过程中被中断，抛出InterruptedException异常，并将线程中断标志清除。
           *
           * @throws InterruptedException if the current thread is interrupted
           */
          public void lockInterruptibly() throws InterruptedException {
              sync.acquireInterruptibly(1);
          }
    
          /**
           * 获取锁。
           * 如果可以获取锁，那么直接返回true，如果不能获取锁，立刻返回false。
           * 获取锁失败不会阻塞当前线程。
           * 该方法会忽略公平和非公平策略。
           *
           * @return {@code true} if the lock was free and was acquired
           * by the current thread, or the write lock was already held
           * by the current thread; and {@code false} otherwise.
           */
          public boolean tryLock( ) {
              return sync.tryWriteLock();
          }
    
          /**
           * 获取锁
           * 和lockInterruptibly方法类似，不同在于这个方法支持设置超时时间。
           * 如果超过超时时间，线程唤醒，获取锁失败
           *
           * @param timeout the time to wait for the write lock
           * @param unit the time unit of the timeout argument
           *
           * @return {@code true} if the lock was free and was acquired
           * by the current thread, or the write lock was already held by the
           * current thread; and {@code false} if the waiting time
           * elapsed before the lock could be acquired.
           *
           * @throws InterruptedException if the current thread is interrupted
           * @throws NullPointerException if the time unit is null
           */
          public boolean tryLock(long timeout, TimeUnit unit)
                  throws InterruptedException {
              return sync.tryAcquireNanos(1, unit.toNanos(timeout));
          }
    
          /**
           * 释放写锁
           * 如果是重入，那么将重入次数减一。
           * 由于重入情况的存在，所以调用了unlock，线程依然可能持有写锁。
           *
           * @throws IllegalMonitorStateException if the current thread does not
           * hold this lock
           */
          public void unlock() {
              sync.release(1);
          }
    }
    ```

ReentrantReadWriteLock定义了Sync实现获取锁和释放锁的同步器方法，NonfairSync和FairSync实现非公平策略和非公平策略获取锁的方式，ReadLock和WriteLock定义获取读锁和获取写锁。

ReentrantReadWriteLock还提供了一些方法用于提供当前ReentrantReadWriteLock的状态，比如：

-   isFair()：当前ReentrantReadWriteLock使用的公平和非公平策略。true表示公平策略，false表示非公平策略
-   getOwner()：持有同步器的线程。如果没有则返回Null
-   getReadLockCount()：获取读锁的重入次数
-   isWriteLocked()：同步器当前是否有线程获取了写锁。true表示有线程获取了写锁；false表示当前没有线程获取写锁。
-   isWriteLockedByCurrentThread()：同步器是否被当前线程持有。
-   getWriteHoldCount()：当前线程持有的写锁重入次数
-   getReadHoldCount()：当前线程持有的读锁的重入次数
-   getQueuedWriterThreads()：返回等待队列中等待获取写锁的线程集合。数据从队尾开始搜集，所以队列靠后的线程排在集合位置的前面。
-   getQueuedReaderThreads()：返回等待队列中等待获取读锁的线程集合。数据从队尾开始搜集，所以队列靠后的线程排在集合位置的前面。
-   hasQueuedThreads()：等待队列中是否有线程等待获取锁。
-   hasQueuedThread(Thread thread)：给定的线程是否在等待队列中等待获取锁。
-   getQueueLength()：等待队列的长度
-   getQueuedThreads()：获取等待队列中等待获取锁的线程集合。数据从队尾开始搜集，所以队列靠后的线程排在集合位置的前面。
-   hasWaiters(Condition condition)：是否有线程等待竞态条件
-   getWaitQueueLength(Condition condition)：获取等待竞态条件的线程数
-   getWaitingThreads(Condition condition)：返回等待竞态条件的线程集合。从队头开始收集，所以队列靠前的线程排在集合位置的前面。
-   getWaitQueueLength(Condition condition)：获取等待竞态条件的线程数
-   getWaitingThreads(Condition condition)：返回等待竞态条件的线程集合。从队头开始收集，所以队列靠前的线程排在集合位置的前面。

ReentrantReadWriteLock利用Unsafe方法获取到同步其中state，head，tail属性的内存地址，Node对象的waitStatus，next属性的内存地址，并利用unsafe比较修改的方式（CAS）原子修改属性的值，保证线程安全。  

